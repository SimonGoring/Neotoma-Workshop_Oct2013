**Navigation - [Home](../README.html) - [Basic Search](../BasicSearches/BasicSearches.html)**

Introduction to R
========================================================

### Palynological Databases: Hands-on Computer Workshop, AASP 46th Meeting, San Francisco

This lab is designed to give you a gentle introduction to R. It will cover basic functionality of R, including variables and functions, together with some examples using descriptive statistics and plotting. If you have not already used R, it is recommended that you work through the first two sections of this document before starting to work with the RNeotoma package.

We will be using a file of pollen data for this lab: _percSite.csv_

Data in R
---------------
One of the main ways in which R differs from spreadsheet software is that it uses a _workspace_ in the memory of your computer, and the data you use and create is stored there as a _variable_: an _object_ with a _name_ and a _value_. This first section will introduce the different types of variable and how to manipulate them.

### Variables in R
The basic form of a variable in R comes in two parts, the variable name (e.g. x) and the value that
is attributed to it (e.g. 5). The assignment operators (`=` and `<-`) are used to associate a given value with a variable. For example `x <- 5` gives the value 5 to a variable called `x` and creates it if it does not exist. Once a variable is created, the value is not fixed and may be modified at anytime, and also may be used in subsequent operations. Note that as you create variables, nothing will appear on the screen. To see the value(s) assigned to any variable, simply type its name at the prompt. Try entering the following commands at the command prompt:

```{r FirstBlock, echo=TRUE, results='hide'}
x <- 5
x
sqrt(x)
x <- 9
x
sqrt(9)
```

### Data modes in R
R can deal with many different types or modes of data, but some of the most common are:
- Numeric, e.g. 5 or 6e-5  
- Character  e.g. 'San Francisco' or 'London'
- Factor e.g. 'male' or 'female'
- Logic	True/False

### Data structures in R
In addition to the data types, R has many standard structures (or objects) for storing data. These include:
- Single variables (0D): e.g. the population of Australia
- Vectors (1D, 1 mode): e.g. the population size of each of the 20 largest cities of the world
- Matrices (2D, 1 mode): a gridded climate field, a raster image
- Arrays (nD, 1 mode): a stack of raster images for different time periods
- Data frames (2D, multiple modes): a population survey - where many different types may be recorded for the same observation
- Lists: A collection of other data objects


Manipulating variables in R
---------------------------------------
### Reading data from files
R can use many different file types, but csv files are recommended as the easiest way to transfer between R and Excel. Start by changing your working directory to the directory holding the two files listed above. Then get a list of files as follows (note the use of the `pattern` parameter to get only certain files):
```{r}
list.files("./", pattern=".csv")
```
Now read in a file
```{r}
pollen <- read.csv("percSite.csv")
```
And check to see the variable `pollen` that has been created in the R workspace (note that variable `x` we created earlier is also there).
```{r}
ls()
```

R will store data read in a dataframe. To print out the contents of any variable, simply type the name of that variable at the command prompt. Other useful commands are `class()` to see what data class a variable is, and `names()` to get a list of the column headers. The function `str()` reports the structure of the data set, describing the column names and the type of data stored in them.
```{r, results='hide'}
pollen
class(pollen)
names(pollen)
str(pollen)
```

In order to access the values in a dataframe or other R object, there are two main methods: column notation and indexing. Column notation uses the dollar sign ($) after the name of dataframe, with the column name appended (note that R replaces any white spaces in the column names with '.'). For example:
```{r, results='hide'}
pollen$Betula
pollen$Pinus.subg..Strobus
```
Indexing uses a coordinate system to access variables. These are given in brackets after the name of the object, and take as many indexes as there are dimensions of the data object. So for a 1D vector, we require one, for a 2D matrix or data frame, we require two, etc. For matrices and data frames, the indices are [row,column]. If either of these are left blank, then all rows (or columns) are selected:
```{r, results='hide'}
pollen[ ,1:4]			# Columns 1 to 4
pollen[1:10, ]			# First 10 rows
pollen[1:20,1:2]	# Indices can be combined
pollen$Betula[1:25]	# Note that indices can be combined
pollen$Betula[3]  		# 3rd element
pollen$Betula[-3]		# All but 3rd element
```

Logical operators $<, <=, >, >=, ==, !=$ can be used to select parts of the data set by value. This is very useful if you only want to analyze part of your dataset, or split your dataset into groups:
```{r, results='hide'}
pollen$Betula[pollen$agecal < 5000]  # All Betula counts with an age < 5ka BP
pollen$Betula[pollen$Pinus.subg..Strobus > 70]  # All Betula counts when Pine > 70%
```
### Writing data to files
Variables created in R may also written out to csv files using the `write.csv()` function.
```{r, results='hide'}
x <- pollen$Betula[pollen$agecal < 5000]
write.csv(x, "test.csv")
```
This will write a csv file called _test.csv_ in your working directory, containing the values in the vector `x`, created from the original data frame . Note that R uses the variable name as a column header and adds a column with line numbers. You can remove the line numbers by adding the parameter `row.names=FALSE` to the `write.csv()` function. 

Functions in R
----------------
Functions typically are comprised of the name of the function (`sqrt()` for taking square roots) and a set of parentheses. The parentheses are used to pass data to the function as well as setting parameters to change the behavior of the function.
```{r, results='hide'}
sqrt(5)
```

Note that we can use the assignment operator to save the output from a function, allowing you to use this in subsequent functions and analyses. 
```{r, results='hide'}
y = sqrt(5)
round(y)
```
To save time and code, functions can be combined:
```{r, results='hide'}
round(sqrt(5))
```

The `seq()` function produces a series of numbers on a regular step. By default, it require 3 parameters, the starting number, the ending number and the step.
```{r, results='hide'}
seq(from=0,to=20,by=2)
```
If you include the parameter names, as in this example, the order does not matter. The parameter names can be omitted if you keep to the specified order of parameters. So this will give you the equivalent results.
```{r, results='hide'}
seq(0,20,2)
```
To find out what these parameters are, what they are called and what values they take, use the `help()` function or the `?` operator, e.g.:
```{r, eval=FALSE}
help(seq)
?seq
```
This will open a window with the help file for that function. If you do not know the name of a function, there is a search function `help.search()`, or use the help browser `help.start()`, browse to packages or use the search engine.

Some basic statistical functions
--------------------------------
We will now create some new vectors in R containing Betula and Pine percentages and the age vector, in order to use these with functions. Note the use of the assignment operator `<-`. You can also use the equal sign  (`=`) here and elsewhere in these examples.
```{r, results='hide'}
bet <- pollen$Betula
pin <- pollen$Pinus.subg..Strobus
age <- pollen$agebp
```

R has a large number of inbuilt functions. This section is designed to simply introduce you to the some basic functions for describing data.
### Functions to describe the central tendancy:
```{r, results='hide'}
mean(bet)
median(bet)
```

### Functions to describe the dispersion:
```{r, results='markup'}
sd(bet)
var(bet)
min(age)
max(age)
range(age)
quantile(age)
```
Note that `quantile()` takes a parameter that allows you to choose the quantile to be calculated, e.g. `quantile(sl, c(0.1,0.9))`, will calculate the 10th and 90th percentile. I highly recommend that you read the help pages for these functions to understand what they do and how they can be modified. 

### Some other useful functions:
```{r, results='hide'}
sum(bet)
summary(bet)
```

R is object oriented, and so many functions will adapt to different data types. For example, the summary() function will provide a different output for a vector and a data frame:
```{r, results='hide'}
summary(bet) ## Summary of numeric vector
summary(pollen) ## Summary of data frame
```

Bivariate statistics
--------------------

### Functions to assess the relationship between pairs of variables.
Standard functions include calculation of the covariance and correlation:
```{r, results='hide'}
cov(bet,pin)
cor(bet,pin)
```
The correlation function gives Pearson's coefficient by default. Look and try to identify strong positive and negative correlations (i.e. values closer to one). We can replace Pearson's method with a robust method, Spearmans rank correlation, by including the parameter `method`:
```{r, results='hide'}
cor(bet,pin, method="spearman")
```
See the help for `cor()` for other parameters. The correlations obtained can be tested using the `cor.test()` function. Is there a significant correlation between Betula and Pine percentages? Is this to be expected?
```{r, results='markup'}
cor.test(bet,pin, method="spearman") # Significance?
```
The output gives you both the correlation coefficient (rho) and the _p_-value from a test against a _t_-distribution.

Plot functions
==============
Enumerative plots
-----------------
The simplest type of plot is an index plot, which simply plots values in the order they are recorded in the input vector. These are useful for examining the basic data structure and identifying errors and outliers. `plot()` is a generic plotting command and will adapt to different data types. The parameter `type='p'` gives the plot type, here using points. Other options are `'l'` for lines, `'h'` for histogram lines, `'s'` for a stepped plot and `'b'` for both line and points. See `help(plot)` for more options and other parameters. 
```{r, fig.keep='none'}
plot(bet, type='p')
```

Summary plots
-----------------
Summary plots attempt to describe the distribution of the data, giving some ideas about which values are most common and which are most rare. Histograms are commonly used for this method, values are 'binned' into a set of classes, and the histogram represents the frequency of occurrences in that bin. Bins are defined with the `breaks` parameter, which may be set to a constant number in which case the data range is split into that many bins, or as a sequence of numbers defining the intervals between bins. In this latter case, we can make use of the `seq()` function from earlier. 
```{r, fig.keep='none'}
hist(bet, breaks=20, main="Histogram of Betula percentages")
hist(bet, breaks=seq(0,40,1),
     main="Histogram of Betula percentages")
```
An alternative to histograms are boxplots, which show information about the data quartiles. Here the box represents the interquartile data (25-75% of the data), the thick bar is the median, and the 'whiskers' show the data range.
```{r, fig.keep='none'}
boxplot(bet)
```
If we use the boxplot function with the full pollen data frame, it will produce boxplots for all taxa:
```{r, fig.keep='none'}
boxplot(pollen[,5:73])
```
To make this a little more useful, we can take only a subset of pollen taxa, and plot them with a square-root transformation. This uses the indexing idea we covered earlier:
```{r, fig.keep='none', results='hide'}
taxaID = c(5,9,24,27,31,32,34,38,47,48)
names(pollen)[taxaID]
boxplot(sqrt(pollen[,taxaID]))
```

Bivariate plots
-----------------
Bivariate plots are designed to show the relationship between two variables, and how this may vary. The simplest form is the scatter plot. We use the `plot()` function again, but now we give it two variables (x and y). We can use this to vosualize the relationship between Betula and Pine shown in the correlation analysis
```{r, fig.keep='none'}
plot(bet,pin)
```
Alternatively, we can plot pollen percentages against time (the third column of the data frame). Note the extra parameters to add better axis labels (`xlab`,`ylab`) and title (`main`).
```{r, fig.keep='none'}
plot(age, bet, type='l', xlab="Yrs BP", ylab="Percent",main="Betula pollen")
```
