<!DOCTYPE html>
<!-- saved from url=(0014)about:internet -->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>Manipulating pollen objects, compressing lists.</title>

<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 12px;
   margin: 8px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 { 
   font-size:2.2em; 
}

h2 { 
   font-size:1.8em; 
}

h3 { 
   font-size:1.4em; 
}

h4 { 
   font-size:1.0em; 
}

h5 { 
   font-size:0.9em; 
}

h6 { 
   font-size:0.8em; 
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre {	
   margin-top: 0;
   max-width: 95%;
   border: 1px solid #ccc;
   white-space: pre-wrap;
}

pre code {
   display: block; padding: 0.5em;
}

code.r, code.cpp {
   background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * { 
      background: transparent !important; 
      color: black !important; 
      filter:none !important; 
      -ms-filter: none !important; 
   }

   body { 
      font-size:12pt; 
      max-width:100%; 
   }
       
   a, a:visited { 
      text-decoration: underline; 
   }

   hr { 
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote { 
      padding-right: 1em; 
      page-break-inside: avoid; 
   }

   tr, img { 
      page-break-inside: avoid; 
   }

   img { 
      max-width: 100% !important; 
   }

   @page :left { 
      margin: 15mm 20mm 15mm 10mm; 
   }
     
   @page :right { 
      margin: 15mm 10mm 15mm 20mm; 
   }

   p, h2, h3 { 
      orphans: 3; widows: 3; 
   }

   h2, h3 { 
      page-break-after: avoid; 
   }
}

</style>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: rgb(88, 72, 246)
   }

   pre .number {
     color: rgb(0, 0, 205);
   }

   pre .comment {
     color: rgb(76, 136, 107);
   }

   pre .keyword {
     color: rgb(0, 0, 255);
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: rgb(3, 106, 7);
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>


<!-- MathJax scripts -->
<script type="text/javascript" src="https://c328740.ssl.cf1.rackcdn.com/mathjax/2.0-latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>



</head>

<body>
<p><strong>Navigation - <a href="https://github.com/SimonGoring/Neotoma-Workshop_Oct2013/blob/master/README.md">Home</a> - <a href="https://github.com/SimonGoring/Neotoma-Workshop_Oct2013/blob/master/IntroToR/IntroR_1.md">Intro to R</a> - <a href="https://github.com/SimonGoring/Neotoma-Workshop_Oct2013/blob/master/WebServices/WebServices.md">Web Services &amp; APIs</a> - <a href="https://github.com/SimonGoring/Neotoma-Workshop_Oct2013/blob/master/BasicSearches/BasicSearches.md">Basic Search</a> - <a href="https://github.com/SimonGoring/Neotoma-Workshop_Oct2013/blob/master/PollenObjects.md">Pollen Objects</a> - <a href="https://github.com/SimonGoring/Neotoma-Workshop_Oct2013/blob/master/PollenObjects.md">Manipulating Pollen</a></strong></p>

<hr/>

<h1>Manipulating pollen objects, compressing lists.</h1>

<p>The central thesis for our project is that there might be differences between turnover rates in high and low elevation sites.  Turnover is simply a metric of dissimilarity, and we can use squared-chord dissimilarity to do this:</p>

<p>\[  diss_{ij} = \sum\limits_{k=1}^n \left ({{p_{ik}}^{1/2} - {p_{jk}}^{1/2}}  \right )^2  \]</p>

<p>Of course, it is important to note that the number of taxa used can have a significant impact on the estimate of dissimilarity.  So one site with only two taxa could have much different baselines of dissimilarity than a site with one hundred taxa.  Since investgator skill (as a proxy for taxonomic specificity) can impact the taxa reported it would be best for us to use standardized taxonomy for analyis.  In the package we (with lots of help from <em><strong>Jeremiah Marsicek</strong></em>) have developed several taxon equivalencies from the published literature.  These are embedded in the function <code>compile_list</code>.</p>

<p><strong>Table</strong>. <em>Table compilations for neotoma pollen taxonomies.</em></p>

<table><thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead><tbody>
<tr>
<td>P25</td>
<td>Derived from Gavin et al (<a href="http://dx.doi.org/10.1016/S0033-5894(03">2003</a>00088-7))</td>
</tr>
<tr>
<td>WS64</td>
<td>Derived from Williams and Shuman (2008).</td>
</tr>
<tr>
<td>WhitmoreFull</td>
<td>Derived from Whitmore et al. (2005)</td>
</tr>
<tr>
<td>WhitmoreSmall</td>
<td>Derived from Whitmore et al. (2005) but all taxa to lowest resolution.</td>
</tr>
</tbody></table>

<p><code>compile_list</code> works directly on your pollen object, so you can call <code>compile_list(high.pol, &#39;WhitmoreFull&#39;)</code> and it would create a new pollen object with the now standardized taxonomy.  Since we have a whole bunch of samples we need to do this in a loop (or vectorize it, if you&#39;ve read (The R Inferno)[<a href="http://www.burns-stat.com/documents/books/the-r-inferno/%5D">http://www.burns-stat.com/documents/books/the-r-inferno/]</a>), so that we process each sample individually before we bring them all together.  We can do this one of two ways, either through a list apply (<code>lapply</code>) or through a loop.  The loop is a bit more intuitive, so lets do it that way:</p>

<pre><code class="r">
new.high &lt;- list()
new.low &lt;- list()

for (i in 1:length(high.el)) {
    new.high[[i]] &lt;- try(compile_list(high.pol[[i]], &quot;WhitmoreSmall&quot;, type = TRUE, 
        cf = TRUE))
}

for (i in 1:length(low.el)) {
    new.low[[i]] &lt;- try(compile_list(low.pol[[i]], &quot;WhitmoreSmall&quot;, type = TRUE, 
        cf = TRUE))
}
</code></pre>

<p>So we&#39;ve compressed the taxon list, we can take a look at which taxa were lumped by looking at the <code>taxon.list</code> attribute of your sample.  The <code>taxon.list</code> has a number of columns, and you can see what they are using <code>colnames(high.pol[[1]]$taxon.list)</code>, and if you check the compressed pollen dataset you&#39;ll see that a new column <code>compressed</code> has been added.  This allows you to compare the original taxa described for the core and the equivalent taxa used in the compressed list.  <strong>This is an important check!</strong>  You can also look at the raw pollen equivalence table, it is stored in the package as a data.frame:</p>

<pre><code>data(pollen.equiv)
head(pollen.equiv)
</code></pre>

<p>Now we have a set of pollen samples from low elevation sites, and a set of samples from high elevation sites.  This next step is probably the most complicated, we need to do a few things:</p>

<ol>
<li> We need to calculate turnover between stratigraphic levels</li>
<li> We need to normalize it by the time-frame between samples</li>
<li> We need to bring this data together into a single <code>data.frame</code></li>
</ol>

<p>There are some reasons why step 2 is not entirely correct, but it&#39;s okay for the purposes of this workshop.  So lets go step by step.  First we need to calculate the turnover, but we&#39;re only doing it for samples that are younger than 1000ybp.  So lets write a little loop again.  In reality, it might be better to do this as a function, but lets&#39; not worry about that.</p>

<pre><code class="r">
high.steps &lt;- sum(sapply(new.high, function(x) sum(x$sample.meta$Age &lt; 1000, 
    na.rm = TRUE)))
</code></pre>

<pre><code>## Error: $ operator is invalid for atomic vectors
</code></pre>

<pre><code class="r">low.steps &lt;- sum(sapply(new.low, function(x) sum(x$sample.meta$Age &lt; 1000, na.rm = TRUE)))

steps &lt;- high.steps + low.steps
</code></pre>

<pre><code>## Error: object &#39;high.steps&#39; not found
</code></pre>

<pre><code class="r">
output &lt;- data.frame(midpoint = rep(NA, steps), dissim = rep(NA, steps), site = rep(NA, 
    steps), lat = rep(NA, steps), long = rep(NA, steps), elev = rep(NA, steps))
</code></pre>

<pre><code>## Error: object &#39;steps&#39; not found
</code></pre>

<pre><code class="r">
get_dissim &lt;- function(x, elev) {

    good &lt;- x$sample.meta$Age &lt; 1000

    if (sum(good, na.rm = TRUE) &gt; 1) {

        samples &lt;- x$counts[good, !colnames(x$count) %in% &quot;Other&quot;]
        samp.pct &lt;- samples/rowSums(samples, na.rm = TRUE)

        dissims &lt;- rowSums(diff(samp.pct^0.5)^2)
        age.diffs &lt;- diff(x$sample.meta$Age[good])

        age.midpoint &lt;- diff(x$sample.meta$Age[good])/2 + x$sample.meta$Age[good][-sum(good)]

        output &lt;- data.frame(midpoint = age.midpoint, dissim = dissims/age.diffs, 
            site = x$metadata$site.data$SiteName, lat = x$metadata$site.data$LatitudeNorth, 
            long = x$metadata$site.data$LongitudeWest, elev = elev)
    } else {
        output &lt;- data.frame(midpoint = NA, dissim = NA, site = x$metadata$site.data$SiteName, 
            lat = x$metadata$site.data$LatitudeNorth, long = x$metadata$site.data$LongitudeWest, 
            elev = elev)
    }
    output
}

get_dissim(new.high[[1]], elev = &quot;high&quot;)
</code></pre>

<pre><code>##     midpoint    dissim    site    lat   long elev
## 392    151.5 0.0023656 Aguilar -23.83 -65.75 high
## 393    378.5 0.0005803 Aguilar -23.83 -65.75 high
## 394    605.5 0.0000907 Aguilar -23.83 -65.75 high
</code></pre>

<pre><code class="r">
dissim.time &lt;- rbind(ldply(new.high, get_dissim, elev = &quot;high&quot;), ldply(new.low, 
    get_dissim, elev = &quot;low&quot;))
</code></pre>

<pre><code>## Error: $ operator is invalid for atomic vectors
</code></pre>

<p>So, in this case, we get a really nicely formed <code>data.frame</code>. We can plot these out</p>

<pre><code class="r">dissim.time &lt;- dissim.time[rowSums(is.na(dissim.time)) == 0 &amp; is.finite(dissim.time[, 
    2]) &amp; dissim.time[, 2] &gt; 0, ]
</code></pre>

<pre><code>## Error: object &#39;dissim.time&#39; not found
</code></pre>

<pre><code class="r">dissim.time &lt;- dissim.time[dissim.time$long &lt; -20 &amp; dissim.time$lat &gt; 20, ]
</code></pre>

<pre><code>## Error: object &#39;dissim.time&#39; not found
</code></pre>

<pre><code class="r">
ggplot(dissim.time, aes(x = midpoint, y = dissim, color = elev)) + geom_point() + 
    scale_x_reverse(expand = c(0, 0)) + scale_y_sqrt(expand = c(0, 0)) + geom_smooth(method = &quot;gam&quot;, 
    family = Gamma, formula = y ~ s(x), size = 2) + theme_bw() + theme(text = element_text(size = 24, 
    family = &quot;serif&quot;), axis.text = element_text(size = 14, family = &quot;serif&quot;)) + 
    xlab(&quot;Years Before Present&quot;) + ylab(&quot;Sq. Chord Turnover / yr&quot;)
</code></pre>

<pre><code>## Error: object &#39;dissim.time&#39; not found
</code></pre>

<p>So it looks like there&#39;s a difference.  Low elevation sites seem to have overall higher turnover through the last 1000 years (possibly due to higher overal diversity of pollen taxa), but in particular the last 100 years show a significant change.  </p>

<pre><code class="r">
model.0 &lt;- gam(dissim ~ 1, data = dissim.time, family = Gamma)
</code></pre>

<pre><code>## Error: object &#39;dissim.time&#39; not found
</code></pre>

<pre><code class="r">model.1 &lt;- gam(dissim ~ s(midpoint), data = dissim.time, family = Gamma)
</code></pre>

<pre><code>## Error: object &#39;dissim.time&#39; not found
</code></pre>

<pre><code class="r">model.2 &lt;- gam(dissim ~ s(midpoint) + elev, data = dissim.time, family = Gamma)
</code></pre>

<pre><code>## Error: object &#39;dissim.time&#39; not found
</code></pre>

<pre><code class="r">model.3 &lt;- gam(dissim ~ s(midpoint, by = elev), data = dissim.time, family = Gamma)
</code></pre>

<pre><code>## Error: object &#39;dissim.time&#39; not found
</code></pre>

<pre><code class="r">
anova(model.0, model.1, test = &quot;F&quot;)
</code></pre>

<pre><code>## Error: object &#39;model.0&#39; not found
</code></pre>

<pre><code class="r">anova(model.1, model.2, test = &quot;F&quot;)
</code></pre>

<pre><code>## Error: object &#39;model.1&#39; not found
</code></pre>

<pre><code class="r">anova(model.2, model.3, test = &quot;F&quot;)
</code></pre>

<pre><code>## Error: object &#39;model.2&#39; not found
</code></pre>

<p>And so, this simple exploratory work, that really took me one day to code up (along with all this writing) gets us to a point where we can test our hypothesis.</p>

<hr/>

<p><strong>H<sub>0</sub></strong>: The ANOVA comparing <code>model.1</code> and <code>model.2</code> indicates that there is a difference between high elevation and low elevation curves, but that this can be explained by a binary variable, so we can reject <strong>H<sub>0</sub></strong>.</p>

<p><strong>H<sub>1</sub></strong>: When we compare <code>model.2</code> to <code>model.3</code> we see that letting the two spline curves differ in shape (as in the figure) doesn&#39;t improve the model.  This means that we would reject <strong>H<sub>2</sub></strong>.  </p>

<p><strong>H<sub>2</sub></strong>:  I gave it away already, this one is rejected.</p>

<p>So, the rates of change have increased uniformly for both high and low sites, but lower sites have uniformly higher baseline rates of turnover and an increase in turnover rates since ~250ybp (since <code>model.0</code> was rejected).</p>

</body>

</html>

